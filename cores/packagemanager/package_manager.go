package packagemanager

import (
	"sync"

	"github.com/bcmi-labs/arduino-cli/cores/packageindex"
	"fmt"
	"github.com/bcmi-labs/arduino-cli/cores"
	"github.com/bcmi-labs/arduino-cli/configs"
	"os"
	"path/filepath"
	"github.com/juju/errors"
	"github.com/bcmi-labs/arduino-cli/common/releases"
)

var packageManagerInstance *packageManager
var once sync.Once

// PackageManager defines the superior oracle which understands all about
// Arduino Packages, how to parse them, download, and so on.
//
// The manager also keeps track of the status of the Packages (their Platform Releases, actually)
// installed in the system.
type packageManager struct {
	/* FIXME

		What's the typical flow?

		1. You start by downloading a PackageIndex from a repository (remember: multiple repositories are allowed)
		2. You update (say initialize for now) the index with one or more of those PackageIndex es
		3. That will generate and Index structure which does not contain low-level data (i.e. platform properties, boards, etc),
	       since you need to properly install Platform (releases) and Tools
	       So we need a way to find out whether a Platform is installed or not.
	*/

	packages *cores.Packages
	// TODO: This might be a list in the future, but would it be of any help?
	eventHandler EventHandler
}

// EventHandler defines the events that are generated by the PackageManager
// Subscribing to such events allows, for instance, to print out logs of what is happening
// (say you use them for a CLI...)
type EventHandler interface {
	// FIXME: This is temporary, for prototyping (an handler should not return an handler; besides, this leakes
	// the usage of releases...)
	OnDownloadingSomething() releases.ParallelDownloadProgressHandler
}

// PackageManager return the instance of the PackageManager
// yeah, that's a singleton by the way...
func PackageManager() *packageManager {
	once.Do(func() {
		// TODO: why not just use the Go pkg init()?
		packageManagerInstance = &packageManager{}
		// TODO: perhaps directly use the loading from PackagesIndex file?
		packageManagerInstance.packages = cores.NewPackages()
	})

	return packageManagerInstance
}

// FIXME add an handler to be invoked on each verbose operation, in order to let commands display results through the formatter
// as for the progress bars during download
func (pm *packageManager) RegisterEventHandler(eventHandler EventHandler) {
	if pm.eventHandler != nil {
		panic("Don't try to register another event handler to the PackageManager yet!")
	}

	pm.eventHandler = eventHandler
}

// GetEventHandlers returns a slice of the registered EventHandlers
func (pm *packageManager) GetEventHandlers() []*EventHandler {
	return append([]*EventHandler{}, &pm.eventHandler)
}

// FIXME this is currently hard-coded with the default PackageIndex and won't merge or check existing Packages!!
func (pm *packageManager) AddDefaultPackageIndex() (*packageManager, error) {
	var index packageindex.Index
	err := packageindex.LoadIndex(&index)
	if err != nil {
		//TODO: The original version would automatically fix corrupted index?
		/*status, err := prettyPrints.CorruptedCoreIndexFix(index)
		if err != nil {
			return pm, err
		}
		pm.packages = &status
		return pm, nil*/

		return pm, errors.Annotate(err, fmt.Sprintf("failed to load the package index, is probably corrupted"))
	}

	// TODO: if this really is a singleton, a lock is needed :(
	pm.packages = index.CreateStatusContext()
	return pm, nil
}

// TODO: implement the generic version (with merge)
/*func (pm *packageManager) AddPackageIndex() *packageManager {

}*/

// DownloadDefaultPackageIndexFile downloads the core packages index file from Arduino repository.
func (pm *packageManager) DownloadDefaultPackageIndexFile() error {
	return packageindex.DownloadDefaultPackageIndexFile()
}

// Package looks for the Package with the given name, returning a structure
// able to perform further operations on that given resource
func (pm *packageManager) Package(name string) *packageActions {
	//TODO: perhaps these 2 structure should be merged? cores.Packages vs pkgmgr??
	var err error
	thePackage := pm.packages.Packages[name]
	if thePackage == nil {
		err = fmt.Errorf("package '%s' not found", name)
	}
	return &packageActions{
		aPackage:     thePackage,
		forwardError: err,
	}
}

// Actions that can be done on a Package

// packageActions defines what actions can be performed on the specific Package
// It serves as a status container for the fluent APIs
type packageActions struct {
	aPackage     *cores.Package
	forwardError error
}

// Tool looks for the Tool with the given name, returning a structure
// able to perform further operations on that given resource
func (pa *packageActions) Tool(name string) *toolActions {
	var tool *cores.Tool
	err := pa.forwardError
	if err == nil {
		tool = pa.aPackage.Tools[name]

		if tool == nil {
			err = fmt.Errorf("tool '%s' not found in package '%s'", name, pa.aPackage.Name)
		}
	}
	return &toolActions{
		tool:         tool,
		forwardError: err,
	}
}

// END -- Actions that can be done on a Package

// Actions that can be done on a Tool

// toolActions defines what actions can be performed on the specific Tool
// It serves as a status container for the fluent APIs
type toolActions struct {
	tool         *cores.Tool
	forwardError error
}

// Get returns the final representation of the Tool
func (ta *toolActions) Get() (*cores.Tool, error) {
	err := ta.forwardError
	if err == nil {
		return ta.tool, nil
	}
	return nil, err
}

// IsInstalled checks whether the Tool is installed in the system
func (ta *toolActions) IsInstalled() (bool, error) {
	err := ta.forwardError
	if err != nil {
		return false, err
	}

	location, err := configs.ToolsFolder(ta.tool.Package.Name).Get()
	if err != nil {
		return false, err
	}
	_, err = os.Stat(filepath.Join(location, ta.tool.Name))
	if !os.IsNotExist(err) {
		return true, nil
	}
	return false, nil
}

// END -- Actions that can be done on a Tool
